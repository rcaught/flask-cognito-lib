{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Flask Cognito Lib A Flask extension that supports protecting routes with AWS Cognito following OAuth 2.1 best practices . That means the full authorization code flow, including Proof Key for Code Exchange (RFC 7636) to prevent Cross Site Request Forgery (CSRF), along with secure storage of access tokens in HTTP only cookies (to prevent Cross Site Scripting attacks), and additional nonce validation (if using ID tokens) to prevent replay attacks. Optionally, OAuth refresh flow can be enabled, with the refresh token stored in a HTTP-only cookie with optional Fernet symmetrical encryption using Flask's SECRET_KEY (encryption is enabled by default). Documentation : https://mblackgeo.github.io/flask-cognito-lib Source Code : https://github.com/mblackgeo/flask-cognito-lib Installation Use the package manager pip to install: pip install flask-cognito-lib Quick start A complete example Flask application is provided in /example including instructions on setting up a Cognito User Pool. Assuming a Cognito user pool has been setup, with an app client (with Client ID and Secret), get started as follows: from flask import Flask , jsonify , redirect , session , url_for from flask_cognito_lib import CognitoAuth from flask_cognito_lib.decorators import ( auth_required , cognito_login , cognito_login_callback , cognito_logout , cognito_refresh_callback , ) app = Flask ( __name__ ) # Configuration required for CognitoAuth app . config [ \"AWS_REGION\" ] = \"eu-west-1\" app . config [ \"AWS_COGNITO_USER_POOL_ID\" ] = \"eu-west-1_qwerty\" app . config [ \"AWS_COGNITO_DOMAIN\" ] = \"https://app.auth.eu-west-1.amazoncognito.com\" app . config [ \"AWS_COGNITO_USER_POOL_CLIENT_ID\" ] = \"asdfghjkl1234asdf\" app . config [ \"AWS_COGNITO_USER_POOL_CLIENT_SECRET\" ] = \"zxcvbnm1234567890\" app . config [ \"AWS_COGNITO_REDIRECT_URL\" ] = \"https://example.com/postlogin\" app . config [ \"AWS_COGNITO_LOGOUT_URL\" ] = \"https://example.com/postlogout\" app . config [ \"AWS_COGNITO_REFRESH_FLOW_ENABLED\" ] = True app . config [ \"AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED\" ] = True app . config [ \"AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS\" ] = 86400 auth = CognitoAuth ( app ) @app . route ( \"/login\" ) @cognito_login def login (): # A simple route that will redirect to the Cognito Hosted UI. # No logic is required as the decorator handles the redirect to the Cognito # hosted UI for the user to sign in. # An optional \"state\" value can be set in the current session which will # be passed and then used in the postlogin route (after the user has logged # into the Cognito hosted UI); this could be used for dynamic redirects, # for example, set `session['state'] = \"some_custom_value\"` before passing # the user to this route pass @app . route ( \"/postlogin\" ) @cognito_login_callback def postlogin (): # A route to handle the redirect after a user has logged in with Cognito. # This route must be set as one of the User Pool client's Callback URLs in # the Cognito console and also as the config value AWS_COGNITO_REDIRECT_URL. # The decorator will store the validated access token in a HTTP only cookie # and the user claims and info are stored in the Flask session: # session[\"claims\"] and session[\"user_info\"]. # Do anything after the user has logged in here, e.g. a redirect or perform # logic based on a custom `session['state']` value if that was set before # login return redirect ( url_for ( \"claims\" )) @app . route ( \"/refresh\" , methods = [ \"POST\" ]) @cognito_refresh_callback def refresh (): # A route to handle the token refresh with Cognito. # The decorator will exchange the refresh token for new access and refresh tokens. # The new validated access token will be stored in an HTTP only secure cookie. # The refresh token will be symmetrically encrypted(by default) # and stored in an HTTP only secure cookie. # The user claims and info are stored in the Flask session: # session[\"claims\"] and session[\"user_info\"]. # Do anything after the user has refreshed access token here, e.g. a redirect # or perform logic based on the `session[\"user_info\"]`. pass @app . route ( \"/claims\" ) @auth_required () def claims (): # This route is protected by the Cognito authorisation. If the user is not # logged in at this point or their token from Cognito is no longer valid # a 401 Authentication Error is thrown, which can be caught by registering # an `@app.error_handler(AuthorisationRequiredError)`. # If their session is valid, the current session will be shown including # their claims and user_info extracted from the Cognito tokens. return jsonify ( session ) @app . route ( \"/admin\" ) @auth_required ( groups = [ \"admin\" ]) def admin (): # This route will only be accessible to a user who is a member of all of # groups specified in the \"groups\" argument on the auth_required decorator # If they are not, a 401 Authentication Error is thrown, which can be caught # by registering an `@app.error_handler(CognitoGroupRequiredError)`. # If their session is valid, the set of groups the user is a member of will be # shown. # Could also use: jsonify(session[\"user_info\"][\"cognito:groups\"]) return jsonify ( session [ \"claims\" ][ \"cognito:groups\" ]) @app . route ( \"/edit\" ) @auth_required ( groups = [ \"admin\" , \"editor\" ], any_group = True ) def edit (): # This route will only be accessible to a user who is a member of any of # groups specified in the \"groups\" argument on the auth_required decorator # If they are not, a CognitoGroupRequiredError is raised. return jsonify ( session [ \"claims\" ][ \"cognito:groups\" ]) @app . route ( \"/logout\" ) @cognito_logout def logout (): # Logout of the Cognito User pool and delete the cookies that were set # on login. # Revokes the refresh token to not be used again and removes the cookie. # No logic is required here as it simply redirects to Cognito. pass @app . route ( \"/postlogout\" ) def postlogout (): # This is the endpoint Cognito redirects to after a user has logged out, # handle any logic here, like returning to the homepage. # This route must be set as one of the User Pool client's Sign Out URLs. return redirect ( url_for ( \"home\" )) if __name__ == \"__main__\" : app . run () Config class override There might be some cases where you want to override the default Config class to add custom logic. For example, to generate the redirect_url and logout_redirect dynamically using url_for , you can override the Config class as follows: from flask import url_for from flask_cognito_lib.config import Config class ConfigOverride ( Config ): \"\"\" ConfigOverride class to generate URLs dynamically using `url_for` \"\"\" @property def redirect_url ( self ) -> str : \"\"\"Return the Redirect URL (post-login)\"\"\" return url_for ( endpoint = 'auth.cognito' , _external = True ) @property def logout_redirect ( self ) -> str : \"\"\"Return the Redirect URL (post-logout)\"\"\" return url_for ( endpoint = 'auth.cognito_post_logout' , _external = True ) Then, pass the object of ConfigOverride class when initializing the CognitoAuth plugin as follows: CognitoAuth ( app , cfg = ConfigOverride ()) Or if you are using lazy initialization: CognitoAuth () . init_app ( app , cfg = ConfigOverride ()) Contributing Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change. Please make sure to update tests as appropriate and ensure 100% test coverage. Credits This work started as a fork of the unmaintained Flask-AWSCognito extension, revising the implementation following OAuth 2.1 recommendations, with inspiration from flask-cognito-auth . Whilst there are serveral Cognito extensions available for Flask, none of those implement OAuth 2.1 recommendations, with some plugins not even actively maintained.","title":"Flask Cognito Lib"},{"location":"#flask-cognito-lib","text":"A Flask extension that supports protecting routes with AWS Cognito following OAuth 2.1 best practices . That means the full authorization code flow, including Proof Key for Code Exchange (RFC 7636) to prevent Cross Site Request Forgery (CSRF), along with secure storage of access tokens in HTTP only cookies (to prevent Cross Site Scripting attacks), and additional nonce validation (if using ID tokens) to prevent replay attacks. Optionally, OAuth refresh flow can be enabled, with the refresh token stored in a HTTP-only cookie with optional Fernet symmetrical encryption using Flask's SECRET_KEY (encryption is enabled by default). Documentation : https://mblackgeo.github.io/flask-cognito-lib Source Code : https://github.com/mblackgeo/flask-cognito-lib","title":"Flask Cognito Lib"},{"location":"#installation","text":"Use the package manager pip to install: pip install flask-cognito-lib","title":"Installation"},{"location":"#quick-start","text":"A complete example Flask application is provided in /example including instructions on setting up a Cognito User Pool. Assuming a Cognito user pool has been setup, with an app client (with Client ID and Secret), get started as follows: from flask import Flask , jsonify , redirect , session , url_for from flask_cognito_lib import CognitoAuth from flask_cognito_lib.decorators import ( auth_required , cognito_login , cognito_login_callback , cognito_logout , cognito_refresh_callback , ) app = Flask ( __name__ ) # Configuration required for CognitoAuth app . config [ \"AWS_REGION\" ] = \"eu-west-1\" app . config [ \"AWS_COGNITO_USER_POOL_ID\" ] = \"eu-west-1_qwerty\" app . config [ \"AWS_COGNITO_DOMAIN\" ] = \"https://app.auth.eu-west-1.amazoncognito.com\" app . config [ \"AWS_COGNITO_USER_POOL_CLIENT_ID\" ] = \"asdfghjkl1234asdf\" app . config [ \"AWS_COGNITO_USER_POOL_CLIENT_SECRET\" ] = \"zxcvbnm1234567890\" app . config [ \"AWS_COGNITO_REDIRECT_URL\" ] = \"https://example.com/postlogin\" app . config [ \"AWS_COGNITO_LOGOUT_URL\" ] = \"https://example.com/postlogout\" app . config [ \"AWS_COGNITO_REFRESH_FLOW_ENABLED\" ] = True app . config [ \"AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED\" ] = True app . config [ \"AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS\" ] = 86400 auth = CognitoAuth ( app ) @app . route ( \"/login\" ) @cognito_login def login (): # A simple route that will redirect to the Cognito Hosted UI. # No logic is required as the decorator handles the redirect to the Cognito # hosted UI for the user to sign in. # An optional \"state\" value can be set in the current session which will # be passed and then used in the postlogin route (after the user has logged # into the Cognito hosted UI); this could be used for dynamic redirects, # for example, set `session['state'] = \"some_custom_value\"` before passing # the user to this route pass @app . route ( \"/postlogin\" ) @cognito_login_callback def postlogin (): # A route to handle the redirect after a user has logged in with Cognito. # This route must be set as one of the User Pool client's Callback URLs in # the Cognito console and also as the config value AWS_COGNITO_REDIRECT_URL. # The decorator will store the validated access token in a HTTP only cookie # and the user claims and info are stored in the Flask session: # session[\"claims\"] and session[\"user_info\"]. # Do anything after the user has logged in here, e.g. a redirect or perform # logic based on a custom `session['state']` value if that was set before # login return redirect ( url_for ( \"claims\" )) @app . route ( \"/refresh\" , methods = [ \"POST\" ]) @cognito_refresh_callback def refresh (): # A route to handle the token refresh with Cognito. # The decorator will exchange the refresh token for new access and refresh tokens. # The new validated access token will be stored in an HTTP only secure cookie. # The refresh token will be symmetrically encrypted(by default) # and stored in an HTTP only secure cookie. # The user claims and info are stored in the Flask session: # session[\"claims\"] and session[\"user_info\"]. # Do anything after the user has refreshed access token here, e.g. a redirect # or perform logic based on the `session[\"user_info\"]`. pass @app . route ( \"/claims\" ) @auth_required () def claims (): # This route is protected by the Cognito authorisation. If the user is not # logged in at this point or their token from Cognito is no longer valid # a 401 Authentication Error is thrown, which can be caught by registering # an `@app.error_handler(AuthorisationRequiredError)`. # If their session is valid, the current session will be shown including # their claims and user_info extracted from the Cognito tokens. return jsonify ( session ) @app . route ( \"/admin\" ) @auth_required ( groups = [ \"admin\" ]) def admin (): # This route will only be accessible to a user who is a member of all of # groups specified in the \"groups\" argument on the auth_required decorator # If they are not, a 401 Authentication Error is thrown, which can be caught # by registering an `@app.error_handler(CognitoGroupRequiredError)`. # If their session is valid, the set of groups the user is a member of will be # shown. # Could also use: jsonify(session[\"user_info\"][\"cognito:groups\"]) return jsonify ( session [ \"claims\" ][ \"cognito:groups\" ]) @app . route ( \"/edit\" ) @auth_required ( groups = [ \"admin\" , \"editor\" ], any_group = True ) def edit (): # This route will only be accessible to a user who is a member of any of # groups specified in the \"groups\" argument on the auth_required decorator # If they are not, a CognitoGroupRequiredError is raised. return jsonify ( session [ \"claims\" ][ \"cognito:groups\" ]) @app . route ( \"/logout\" ) @cognito_logout def logout (): # Logout of the Cognito User pool and delete the cookies that were set # on login. # Revokes the refresh token to not be used again and removes the cookie. # No logic is required here as it simply redirects to Cognito. pass @app . route ( \"/postlogout\" ) def postlogout (): # This is the endpoint Cognito redirects to after a user has logged out, # handle any logic here, like returning to the homepage. # This route must be set as one of the User Pool client's Sign Out URLs. return redirect ( url_for ( \"home\" )) if __name__ == \"__main__\" : app . run ()","title":"Quick start"},{"location":"#config-class-override","text":"There might be some cases where you want to override the default Config class to add custom logic. For example, to generate the redirect_url and logout_redirect dynamically using url_for , you can override the Config class as follows: from flask import url_for from flask_cognito_lib.config import Config class ConfigOverride ( Config ): \"\"\" ConfigOverride class to generate URLs dynamically using `url_for` \"\"\" @property def redirect_url ( self ) -> str : \"\"\"Return the Redirect URL (post-login)\"\"\" return url_for ( endpoint = 'auth.cognito' , _external = True ) @property def logout_redirect ( self ) -> str : \"\"\"Return the Redirect URL (post-logout)\"\"\" return url_for ( endpoint = 'auth.cognito_post_logout' , _external = True ) Then, pass the object of ConfigOverride class when initializing the CognitoAuth plugin as follows: CognitoAuth ( app , cfg = ConfigOverride ()) Or if you are using lazy initialization: CognitoAuth () . init_app ( app , cfg = ConfigOverride ())","title":"Config class override"},{"location":"#contributing","text":"Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change. Please make sure to update tests as appropriate and ensure 100% test coverage.","title":"Contributing"},{"location":"#credits","text":"This work started as a fork of the unmaintained Flask-AWSCognito extension, revising the implementation following OAuth 2.1 recommendations, with inspiration from flask-cognito-auth . Whilst there are serveral Cognito extensions available for Flask, none of those implement OAuth 2.1 recommendations, with some plugins not even actively maintained.","title":"Credits"},{"location":"cognito/","text":"Setting up a Cognito User Pool and client About Cognito Cognito is a serverless offering from Amazon Web Services that allows for sign-up/sign-in and user management with OAuth 2.0 and OpenID Connect, as well as federated identities through social identity providers (e.g. Google, Facebook, Amazon) and SAML. It has a generous free tier, with 50,000 monthly active users from the Cognito IdP. To get start protecting routes in your Flask app, first create a new Cognito User Pool and a client for the application: Setup steps Visit the AWS Cognito console, click to create a new user pool (\"Add user directories to your app\") Step 1: Ensure the \"Cognito user pool\" provider is checked, choose any additional sign-in options as required Step 2: Configure your security requirements as needed (e.g. Multi-Factor Authentication, password policy) Step 3: Configure your sign-up experience as required, or leave to defaults Step 4: Configure message delivery, for production apps you should use SES, for testing \"Send email with Cognito\" is sufficient Step 5: Integrate your app Name the user pool Check the box to enable the Hosted UI Setup a domain for the user pool (either a custom domain or the domain prefix) Choose \"Confidential Client\" Set the \"App client name\" Ensure the box is checked to \"Create a client secret\" Under \"Allowed callback URLs\" add the URL of the route that has the @cognito_login_callback - for the example app this should be http://localhost:5000/postlogin Expand the \"Advanced app client settings\" Set the Refresh, Access, and ID Token expiration values to the desired session length for the user (note that refresh tokens are not used) Locate the \"Add Signout URL\" button and add the URL of the route handles logic after logout - for the example app this should be http://localhost:5000/postlogout Review all settings and hit \"Create\" After creation, add users and groups as required","title":"Setting up a Cognito User Pool and client"},{"location":"cognito/#setting-up-a-cognito-user-pool-and-client","text":"","title":"Setting up a Cognito User Pool and client"},{"location":"cognito/#about-cognito","text":"Cognito is a serverless offering from Amazon Web Services that allows for sign-up/sign-in and user management with OAuth 2.0 and OpenID Connect, as well as federated identities through social identity providers (e.g. Google, Facebook, Amazon) and SAML. It has a generous free tier, with 50,000 monthly active users from the Cognito IdP. To get start protecting routes in your Flask app, first create a new Cognito User Pool and a client for the application:","title":"About Cognito"},{"location":"cognito/#setup-steps","text":"Visit the AWS Cognito console, click to create a new user pool (\"Add user directories to your app\") Step 1: Ensure the \"Cognito user pool\" provider is checked, choose any additional sign-in options as required Step 2: Configure your security requirements as needed (e.g. Multi-Factor Authentication, password policy) Step 3: Configure your sign-up experience as required, or leave to defaults Step 4: Configure message delivery, for production apps you should use SES, for testing \"Send email with Cognito\" is sufficient Step 5: Integrate your app Name the user pool Check the box to enable the Hosted UI Setup a domain for the user pool (either a custom domain or the domain prefix) Choose \"Confidential Client\" Set the \"App client name\" Ensure the box is checked to \"Create a client secret\" Under \"Allowed callback URLs\" add the URL of the route that has the @cognito_login_callback - for the example app this should be http://localhost:5000/postlogin Expand the \"Advanced app client settings\" Set the Refresh, Access, and ID Token expiration values to the desired session length for the user (note that refresh tokens are not used) Locate the \"Add Signout URL\" button and add the URL of the route handles logic after logout - for the example app this should be http://localhost:5000/postlogout Review all settings and hit \"Create\" After creation, add users and groups as required","title":"Setup steps"},{"location":"config/","text":"Application configuration Cognito Auth extension configuration The following key/value pairs are used for configurating the extension: Config Name Description AWS_COGNITO_DISABLED Globally disable auth with Cognito (default=False) AWS_REGION Region the user pool was created AWS_COGNITO_DOMAIN The domain name of the user pool AWS_COGNITO_USER_POOL_ID The ID of the user pool AWS_COGNITO_USER_POOL_CLIENT_ID The user pool app client ID (*) AWS_COGNITO_USER_POOL_CLIENT_SECRET The user pool app client secret (*) [Optional for public Cognito clients] AWS_COGNITO_REDIRECT_URL The full URL of the route that handles post-login flow AWS_COGNITO_LOGOUT_URL The full URL of the route that handles post-logout flow AWS_COGNITO_COOKIE_AGE_SECONDS (Optional) How long to store the access token cookie. (default=1800) AWS_COGNITO_EXPIRATION_LEEWAY (Optional) Leeway (in seconds) when checking for token expiry (default=0) AWS_COGNITO_SCOPES (Optional) List of scopes to request from Cognito, if None (default) will get all scopes AWS_COGNITO_COOKIE_DOMAIN (Optional) Domain used for setting a cookie (default=None) AWS_COGNITO_COOKIE_SAMESITE (Optional) Setting for \"samesite\" on the cookie. Choose \"lax\", \"strict\" or None (default) AWS_COGNITO_REFRESH_FLOW_ENABLED (Optional) Enable refresh token flow (default=False) AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED (Optional) Symmetrically encrypt a refresh token cookie using Fernet with the Flask SECRET_KEY (default=True) AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS (Optional) How long to store the refresh token cookie. (default=86400) (*) To obtain these values, navigate to the user pool in the AWS Cognito console, then head to the \"App Integration\" tab. Under the app client list, select the app client and you should be able to view the Client ID and Client Secret Example usage These configuration should be setup and passed to the Flask app object, for example, if they are set in environment variables this could be achieved as follows: from os import environ from flask import Flask class Config : \"\"\"Set Flask configuration vars from .env file.\"\"\" # General Config SECRET_KEY = environ . get ( \"SECRET_KEY\" , urandom ( 32 )) FLASK_APP = \"TEST_APP\" FLASK_ENV = \"TESTING\" # Cognito config AWS_REGION = environ [ \"AWS_REGION\" ] AWS_COGNITO_USER_POOL_ID = environ [ \"AWS_COGNITO_USER_POOL_ID\" ] AWS_COGNITO_DOMAIN = environ [ \"AWS_COGNITO_DOMAIN\" ] AWS_COGNITO_USER_POOL_CLIENT_ID = environ [ \"AWS_COGNITO_USER_POOL_CLIENT_ID\" ] AWS_COGNITO_USER_POOL_CLIENT_SECRET = environ [ \"AWS_COGNITO_USER_POOL_CLIENT_SECRET\" ] AWS_COGNITO_REDIRECT_URL = environ [ \"AWS_COGNITO_REDIRECT_URL\" ] AWS_COGNITO_LOGOUT_URL = environ [ \"AWS_COGNITO_LOGOUT_URL\" ] # Optional # AWS_COGNITO_COOKIE_AGE_SECONDS = environ[\"AWS_COGNITO_COOKIE_AGE_SECONDS\"] # AWS_COGNITO_EXPIRATION_LEEWAY = environ[\"AWS_COGNITO_EXPIRATION_LEEWAY] # AWS_COGNITO_SCOPES = [\"openid\", \"phone\", \"email\"] # AWS_COGNITO_REFRESH_FLOW_ENABLED = environ[\"AWS_COGNITO_REFRESH_FLOW_ENABLED\"] # AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED = environ[\"AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED\"] # AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS = environ[\"AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS\"] app = Flask ( __name__ ) app . config . from_object ( Config )","title":"Application configuration"},{"location":"config/#application-configuration","text":"","title":"Application configuration"},{"location":"config/#cognito-auth-extension-configuration","text":"The following key/value pairs are used for configurating the extension: Config Name Description AWS_COGNITO_DISABLED Globally disable auth with Cognito (default=False) AWS_REGION Region the user pool was created AWS_COGNITO_DOMAIN The domain name of the user pool AWS_COGNITO_USER_POOL_ID The ID of the user pool AWS_COGNITO_USER_POOL_CLIENT_ID The user pool app client ID (*) AWS_COGNITO_USER_POOL_CLIENT_SECRET The user pool app client secret (*) [Optional for public Cognito clients] AWS_COGNITO_REDIRECT_URL The full URL of the route that handles post-login flow AWS_COGNITO_LOGOUT_URL The full URL of the route that handles post-logout flow AWS_COGNITO_COOKIE_AGE_SECONDS (Optional) How long to store the access token cookie. (default=1800) AWS_COGNITO_EXPIRATION_LEEWAY (Optional) Leeway (in seconds) when checking for token expiry (default=0) AWS_COGNITO_SCOPES (Optional) List of scopes to request from Cognito, if None (default) will get all scopes AWS_COGNITO_COOKIE_DOMAIN (Optional) Domain used for setting a cookie (default=None) AWS_COGNITO_COOKIE_SAMESITE (Optional) Setting for \"samesite\" on the cookie. Choose \"lax\", \"strict\" or None (default) AWS_COGNITO_REFRESH_FLOW_ENABLED (Optional) Enable refresh token flow (default=False) AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED (Optional) Symmetrically encrypt a refresh token cookie using Fernet with the Flask SECRET_KEY (default=True) AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS (Optional) How long to store the refresh token cookie. (default=86400) (*) To obtain these values, navigate to the user pool in the AWS Cognito console, then head to the \"App Integration\" tab. Under the app client list, select the app client and you should be able to view the Client ID and Client Secret","title":"Cognito Auth extension configuration"},{"location":"config/#example-usage","text":"These configuration should be setup and passed to the Flask app object, for example, if they are set in environment variables this could be achieved as follows: from os import environ from flask import Flask class Config : \"\"\"Set Flask configuration vars from .env file.\"\"\" # General Config SECRET_KEY = environ . get ( \"SECRET_KEY\" , urandom ( 32 )) FLASK_APP = \"TEST_APP\" FLASK_ENV = \"TESTING\" # Cognito config AWS_REGION = environ [ \"AWS_REGION\" ] AWS_COGNITO_USER_POOL_ID = environ [ \"AWS_COGNITO_USER_POOL_ID\" ] AWS_COGNITO_DOMAIN = environ [ \"AWS_COGNITO_DOMAIN\" ] AWS_COGNITO_USER_POOL_CLIENT_ID = environ [ \"AWS_COGNITO_USER_POOL_CLIENT_ID\" ] AWS_COGNITO_USER_POOL_CLIENT_SECRET = environ [ \"AWS_COGNITO_USER_POOL_CLIENT_SECRET\" ] AWS_COGNITO_REDIRECT_URL = environ [ \"AWS_COGNITO_REDIRECT_URL\" ] AWS_COGNITO_LOGOUT_URL = environ [ \"AWS_COGNITO_LOGOUT_URL\" ] # Optional # AWS_COGNITO_COOKIE_AGE_SECONDS = environ[\"AWS_COGNITO_COOKIE_AGE_SECONDS\"] # AWS_COGNITO_EXPIRATION_LEEWAY = environ[\"AWS_COGNITO_EXPIRATION_LEEWAY] # AWS_COGNITO_SCOPES = [\"openid\", \"phone\", \"email\"] # AWS_COGNITO_REFRESH_FLOW_ENABLED = environ[\"AWS_COGNITO_REFRESH_FLOW_ENABLED\"] # AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED = environ[\"AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED\"] # AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS = environ[\"AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS\"] app = Flask ( __name__ ) app . config . from_object ( Config )","title":"Example usage"},{"location":"example/","text":"Example Flask application A separate repo holds a complete example app , including AWS CDK (Cloud Development Kit) code to deploy the application to API Gateway and Lambda, along with creation of a Cognito User Pool and Client. However, a mimimal example application is shown below that demonstrates the features: app.py from os import environ , path , urandom from dotenv import load_dotenv from flask import Flask , jsonify , redirect , session , url_for from flask_cognito_lib import CognitoAuth from flask_cognito_lib.decorators import ( auth_required , cognito_login , cognito_login_callback , cognito_logout , cognito_refresh_callback , ) from flask_cognito_lib.exceptions import ( AuthorisationRequiredError , CognitoGroupRequiredError , ) # Load variables from .env basedir = path . abspath ( path . dirname ( __file__ )) load_dotenv ( path . join ( basedir , \".env\" )) class Config : \"\"\"Set Flask configuration vars from .env file.\"\"\" # General Config SECRET_KEY = environ . get ( \"SECRET_KEY\" , urandom ( 32 )) FLASK_APP = \"TEST_APP\" FLASK_ENV = \"TESTING\" # Cognito config # AWS_COGNITO_DISABLED = True # Can set to turn off auth (e.g. for local testing) AWS_REGION = environ [ \"AWS_REGION\" ] AWS_COGNITO_USER_POOL_ID = environ [ \"AWS_COGNITO_USER_POOL_ID\" ] AWS_COGNITO_DOMAIN = environ [ \"AWS_COGNITO_DOMAIN\" ] AWS_COGNITO_USER_POOL_CLIENT_ID = environ [ \"AWS_COGNITO_USER_POOL_CLIENT_ID\" ] AWS_COGNITO_USER_POOL_CLIENT_SECRET = environ [ \"AWS_COGNITO_USER_POOL_CLIENT_SECRET\" ] AWS_COGNITO_REDIRECT_URL = environ [ \"AWS_COGNITO_REDIRECT_URL\" ] AWS_COGNITO_LOGOUT_URL = environ [ \"AWS_COGNITO_LOGOUT_URL\" ] AWS_COGNITO_COOKIE_AGE_SECONDS = environ [ \"AWS_COGNITO_COOKIE_AGE_SECONDS\" ] AWS_COGNITO_REFRESH_FLOW_ENABLED = environ [ \"AWS_COGNITO_REFRESH_FLOW_ENABLED\" ] AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED = environ [ \"AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED\" ] AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS = environ [ \"AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS\" ] app = Flask ( __name__ ) app . config . from_object ( Config ) auth = CognitoAuth ( app ) @app . route ( \"/\" ) def home (): return \"Hello world!\" @app . route ( \"/login\" ) @cognito_login def login (): # A simple route that will redirect to the Cognito Hosted UI. # No logic is required as the decorator handles the redirect to the Cognito # hosted UI for the user to sign in. # An optional \"state\" value can be set in the current session which will # be passed and then used in the postlogin route (after the user has logged # into the Cognito hosted UI); this could be used for dynamic redirects, # for example, set `session['state'] = \"some_custom_value\"` before passing # the user to this route pass @app . route ( \"/postlogin\" ) @cognito_login_callback def postlogin (): # A route to handle the redirect after a user has logged in with Cognito. # This route must be set as one of the User Pool client's Callback URLs in # the Cognito console and also as the config value AWS_COGNITO_REDIRECT_URL. # The decorator will store the validated access token in a HTTP only cookie # and the user claims and info are stored in the Flask session: # session[\"claims\"] and session[\"user_info\"]. # Do anything after the user has logged in here, e.g. a redirect or perform # logic based on a custom `session['state']` value if that was set before # login return redirect ( url_for ( \"claims\" )) @app . route ( \"/refresh\" , methods = [ \"POST\" ]) @cognito_refresh_callback def refresh (): # A route to handle the token refresh with Cognito. # The decorator will exchange the refresh token for new access and refresh tokens. # The new validated access token will be stored in an HTTP only secure cookie. # The refresh token will be symmetrically encrypted(by default) # and stored in an HTTP only secure cookie. # The user claims and info are stored in the Flask session: # session[\"claims\"] and session[\"user_info\"]. # Do anything after the user has refreshed access token here, e.g. a redirect # or perform logic based on the `session[\"user_info\"]`. pass @app . route ( \"/claims\" ) @auth_required () def claims (): # This route is protected by the Cognito authorisation. If the user is not # logged in at this point or their token from Cognito is no longer valid # a 401 Authentication Error is thrown, which is caught by the # `auth_error_handler` a redirected to the Hosted UI to login. # If their auth is valid, the current session will be shown including # their claims and user_info extracted from the Cognito tokens. return jsonify ( session ) @app . errorhandler ( AuthorisationRequiredError ) def auth_error_handler ( err ): # Register an error handler if the user hits an \"@auth_required\" route # but is not logged in to redirect them to the Cognito UI return redirect ( url_for ( \"login\" )) @app . route ( \"/admin\" ) @auth_required ( groups = [ \"admin\" ]) def admin (): # This route will only be accessible to a user who is a member of all of # groups specified in the \"groups\" argument on the auth_required decorator # If they are not, a CognitoGroupRequiredError is raised which is handled # by the `missing_group_error_handler` below. # If their auth is valid, the set of groups the user is a member of will be # shown. # Could also use: jsonify(session[\"user_info\"][\"cognito:groups\"]) return jsonify ( session [ \"claims\" ][ \"cognito:groups\" ]) @app . route ( \"/edit\" ) @auth_required ( groups = [ \"admin\" , \"editor\" ], any_group = True ) def edit (): # This route will only be accessible to a user who is a member of any of # groups specified in the \"groups\" argument on the auth_required decorator # If they are not, a CognitoGroupRequiredError is raised which is handled # below. return jsonify ( session [ \"claims\" ][ \"cognito:groups\" ]) @app . errorhandler ( CognitoGroupRequiredError ) def missing_group_error_handler ( err ): # Register an error handler if the user hits an \"@auth_required\" route # but is not in all of groups specified return jsonify ( \"Group membership does not allow access to this resource\" ), 403 @app . route ( \"/logout\" ) @cognito_logout def logout (): # Logout of the Cognito User pool and delete the cookies that were set # on login. # Revokes the refresh token to not be used again and removes the cookie. # No logic is required here as it simply redirects to Cognito. pass @app . route ( \"/postlogout\" ) def postlogout (): # This is the endpoint Cognito redirects to after a user has logged out, # handle any logic here, like returning to the homepage. # This route must be set as one of the User Pool client's Sign Out URLs. return redirect ( url_for ( \"home\" )) if __name__ == \"__main__\" : app . run ( debug = True , port = 5000 ) Requirements file: requirements.txt python - dotenv == 0.19.2 flask - cognito - lib ~= 1.0","title":"Example Flask application"},{"location":"example/#example-flask-application","text":"A separate repo holds a complete example app , including AWS CDK (Cloud Development Kit) code to deploy the application to API Gateway and Lambda, along with creation of a Cognito User Pool and Client. However, a mimimal example application is shown below that demonstrates the features: app.py from os import environ , path , urandom from dotenv import load_dotenv from flask import Flask , jsonify , redirect , session , url_for from flask_cognito_lib import CognitoAuth from flask_cognito_lib.decorators import ( auth_required , cognito_login , cognito_login_callback , cognito_logout , cognito_refresh_callback , ) from flask_cognito_lib.exceptions import ( AuthorisationRequiredError , CognitoGroupRequiredError , ) # Load variables from .env basedir = path . abspath ( path . dirname ( __file__ )) load_dotenv ( path . join ( basedir , \".env\" )) class Config : \"\"\"Set Flask configuration vars from .env file.\"\"\" # General Config SECRET_KEY = environ . get ( \"SECRET_KEY\" , urandom ( 32 )) FLASK_APP = \"TEST_APP\" FLASK_ENV = \"TESTING\" # Cognito config # AWS_COGNITO_DISABLED = True # Can set to turn off auth (e.g. for local testing) AWS_REGION = environ [ \"AWS_REGION\" ] AWS_COGNITO_USER_POOL_ID = environ [ \"AWS_COGNITO_USER_POOL_ID\" ] AWS_COGNITO_DOMAIN = environ [ \"AWS_COGNITO_DOMAIN\" ] AWS_COGNITO_USER_POOL_CLIENT_ID = environ [ \"AWS_COGNITO_USER_POOL_CLIENT_ID\" ] AWS_COGNITO_USER_POOL_CLIENT_SECRET = environ [ \"AWS_COGNITO_USER_POOL_CLIENT_SECRET\" ] AWS_COGNITO_REDIRECT_URL = environ [ \"AWS_COGNITO_REDIRECT_URL\" ] AWS_COGNITO_LOGOUT_URL = environ [ \"AWS_COGNITO_LOGOUT_URL\" ] AWS_COGNITO_COOKIE_AGE_SECONDS = environ [ \"AWS_COGNITO_COOKIE_AGE_SECONDS\" ] AWS_COGNITO_REFRESH_FLOW_ENABLED = environ [ \"AWS_COGNITO_REFRESH_FLOW_ENABLED\" ] AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED = environ [ \"AWS_COGNITO_REFRESH_COOKIE_ENCRYPTED\" ] AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS = environ [ \"AWS_COGNITO_REFRESH_COOKIE_AGE_SECONDS\" ] app = Flask ( __name__ ) app . config . from_object ( Config ) auth = CognitoAuth ( app ) @app . route ( \"/\" ) def home (): return \"Hello world!\" @app . route ( \"/login\" ) @cognito_login def login (): # A simple route that will redirect to the Cognito Hosted UI. # No logic is required as the decorator handles the redirect to the Cognito # hosted UI for the user to sign in. # An optional \"state\" value can be set in the current session which will # be passed and then used in the postlogin route (after the user has logged # into the Cognito hosted UI); this could be used for dynamic redirects, # for example, set `session['state'] = \"some_custom_value\"` before passing # the user to this route pass @app . route ( \"/postlogin\" ) @cognito_login_callback def postlogin (): # A route to handle the redirect after a user has logged in with Cognito. # This route must be set as one of the User Pool client's Callback URLs in # the Cognito console and also as the config value AWS_COGNITO_REDIRECT_URL. # The decorator will store the validated access token in a HTTP only cookie # and the user claims and info are stored in the Flask session: # session[\"claims\"] and session[\"user_info\"]. # Do anything after the user has logged in here, e.g. a redirect or perform # logic based on a custom `session['state']` value if that was set before # login return redirect ( url_for ( \"claims\" )) @app . route ( \"/refresh\" , methods = [ \"POST\" ]) @cognito_refresh_callback def refresh (): # A route to handle the token refresh with Cognito. # The decorator will exchange the refresh token for new access and refresh tokens. # The new validated access token will be stored in an HTTP only secure cookie. # The refresh token will be symmetrically encrypted(by default) # and stored in an HTTP only secure cookie. # The user claims and info are stored in the Flask session: # session[\"claims\"] and session[\"user_info\"]. # Do anything after the user has refreshed access token here, e.g. a redirect # or perform logic based on the `session[\"user_info\"]`. pass @app . route ( \"/claims\" ) @auth_required () def claims (): # This route is protected by the Cognito authorisation. If the user is not # logged in at this point or their token from Cognito is no longer valid # a 401 Authentication Error is thrown, which is caught by the # `auth_error_handler` a redirected to the Hosted UI to login. # If their auth is valid, the current session will be shown including # their claims and user_info extracted from the Cognito tokens. return jsonify ( session ) @app . errorhandler ( AuthorisationRequiredError ) def auth_error_handler ( err ): # Register an error handler if the user hits an \"@auth_required\" route # but is not logged in to redirect them to the Cognito UI return redirect ( url_for ( \"login\" )) @app . route ( \"/admin\" ) @auth_required ( groups = [ \"admin\" ]) def admin (): # This route will only be accessible to a user who is a member of all of # groups specified in the \"groups\" argument on the auth_required decorator # If they are not, a CognitoGroupRequiredError is raised which is handled # by the `missing_group_error_handler` below. # If their auth is valid, the set of groups the user is a member of will be # shown. # Could also use: jsonify(session[\"user_info\"][\"cognito:groups\"]) return jsonify ( session [ \"claims\" ][ \"cognito:groups\" ]) @app . route ( \"/edit\" ) @auth_required ( groups = [ \"admin\" , \"editor\" ], any_group = True ) def edit (): # This route will only be accessible to a user who is a member of any of # groups specified in the \"groups\" argument on the auth_required decorator # If they are not, a CognitoGroupRequiredError is raised which is handled # below. return jsonify ( session [ \"claims\" ][ \"cognito:groups\" ]) @app . errorhandler ( CognitoGroupRequiredError ) def missing_group_error_handler ( err ): # Register an error handler if the user hits an \"@auth_required\" route # but is not in all of groups specified return jsonify ( \"Group membership does not allow access to this resource\" ), 403 @app . route ( \"/logout\" ) @cognito_logout def logout (): # Logout of the Cognito User pool and delete the cookies that were set # on login. # Revokes the refresh token to not be used again and removes the cookie. # No logic is required here as it simply redirects to Cognito. pass @app . route ( \"/postlogout\" ) def postlogout (): # This is the endpoint Cognito redirects to after a user has logged out, # handle any logic here, like returning to the homepage. # This route must be set as one of the User Pool client's Sign Out URLs. return redirect ( url_for ( \"home\" )) if __name__ == \"__main__\" : app . run ( debug = True , port = 5000 ) Requirements file: requirements.txt python - dotenv == 0.19.2 flask - cognito - lib ~= 1.0","title":"Example Flask application"}]}